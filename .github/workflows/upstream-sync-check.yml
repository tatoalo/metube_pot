name: upstream-sync-check

on:
  schedule:
    - cron: "0 3 * * 6" # Every Saturday at 3:00 AM UTC
  workflow_dispatch: # Manual trigger

jobs:
  analyze-upstream:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get latest upstream release
        id: upstream
        env:
          GH_TOKEN: ${{ secrets.TATOALO_REPO_PAT }}
        run: |
          echo "Fetching latest release from alexta69/metube..."

          RELEASE_INFO=$(gh api repos/alexta69/metube/releases/latest)

          TAG=$(echo "$RELEASE_INFO" | jq -r '.tag_name')
          PUBLISHED=$(echo "$RELEASE_INFO" | jq -r '.published_at')
          URL=$(echo "$RELEASE_INFO" | jq -r '.html_url')
          NOTES=$(echo "$RELEASE_INFO" | jq -r '.body // "No release notes available."')

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "published=$PUBLISHED" >> $GITHUB_OUTPUT
          echo "url=$URL" >> $GITHUB_OUTPUT

          # Save release notes to file (handles multiline)
          echo "$NOTES" > /tmp/release_notes.txt

          echo "Latest upstream release: $TAG (published: $PUBLISHED)"

      - name: Get last synced version
        id: sync_state
        env:
          GH_TOKEN: ${{ secrets.TATOALO_REPO_PAT }}
        run: |
          echo "Querying last synced upstream version from issue labels..."

          # Get latest synced version from closed issues with synced: label
          LAST_SYNCED=$(gh issue list \
            --state closed \
            --label "upstream-sync" \
            --json labels,closedAt,number \
            --jq '[.[] | select(.labels[].name | startswith("synced:"))]
                  | sort_by(.closedAt) | last
                  | .labels[] | select(.name | startswith("synced:"))
                  | .name | split(":")[1]' 2>/dev/null || echo "")

          if [ -z "$LAST_SYNCED" ] || [ "$LAST_SYNCED" = "null" ]; then
            echo "No previous sync found, this appears to be the first run."
            echo "last_synced=" >> $GITHUB_OUTPUT
            echo "has_sync_history=false" >> $GITHUB_OUTPUT
          else
            echo "Last synced upstream version: $LAST_SYNCED"
            echo "last_synced=$LAST_SYNCED" >> $GITHUB_OUTPUT
            echo "has_sync_history=true" >> $GITHUB_OUTPUT
          fi

      - name: Get all releases since last sync
        id: releases
        env:
          GH_TOKEN: ${{ secrets.TATOALO_REPO_PAT }}
          LAST_SYNCED: ${{ steps.sync_state.outputs.last_synced }}
          LATEST_TAG: ${{ steps.upstream.outputs.tag }}
        run: |
          echo "Fetching all upstream releases..."

          if [ -z "$LAST_SYNCED" ]; then
            # First run - only analyze latest release
            echo "First run, analyzing only latest release: $LATEST_TAG"
            echo "$LATEST_TAG" > /tmp/releases_to_analyze.txt
            echo "release_count=1" >> $GITHUB_OUTPUT
          else
            # Get all releases since last synced (excluding the synced one)
            gh api repos/alexta69/metube/releases --paginate \
              --jq "[.[] | select(.tag_name > \"$LAST_SYNCED\")] | reverse | .[].tag_name" \
              > /tmp/releases_to_analyze.txt

            RELEASE_COUNT=$(wc -l < /tmp/releases_to_analyze.txt | tr -d ' ')

            if [ "$RELEASE_COUNT" -eq 0 ]; then
              echo "No new releases since $LAST_SYNCED"
              echo "release_count=0" >> $GITHUB_OUTPUT
            else
              echo "Found $RELEASE_COUNT new release(s) since $LAST_SYNCED:"
              cat /tmp/releases_to_analyze.txt
              echo "release_count=$RELEASE_COUNT" >> $GITHUB_OUTPUT
            fi
          fi

          # Save releases list for LLM context
          echo "releases_list=$(cat /tmp/releases_to_analyze.txt | tr '\n' ',' | sed 's/,$//')" >> $GITHUB_OUTPUT

      - name: Check if analysis needed
        id: check
        env:
          GH_TOKEN: ${{ secrets.TATOALO_REPO_PAT }}
          RELEASE_TAG: ${{ steps.upstream.outputs.tag }}
          RELEASE_COUNT: ${{ steps.releases.outputs.release_count }}
          LAST_SYNCED: ${{ steps.sync_state.outputs.last_synced }}
        run: |
          echo "Checking if analysis is needed..."

          # Skip if no new releases since last sync
          if [ "$RELEASE_COUNT" = "0" ]; then
            echo "Already synced to $LAST_SYNCED, no new releases to analyze."
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "skip_reason=already_synced" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Search for existing issue with this release tag in title
          EXISTING=$(gh issue list \
            --search "Upstream Sync Analysis: $RELEASE_TAG in:title" \
            --json number \
            --jq '.[0].number // empty')

          if [ -n "$EXISTING" ]; then
            echo "Already analyzed in issue #$EXISTING, skipping."
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "existing_issue=$EXISTING" >> $GITHUB_OUTPUT
            echo "skip_reason=issue_exists" >> $GITHUB_OUTPUT
          else
            echo "Analysis needed for $RELEASE_COUNT new release(s)."
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup labels
        if: steps.check.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.TATOALO_REPO_PAT }}
        run: |
          # Create labels if they don't exist
          gh label create "upstream-sync" \
            --repo ${{ github.repository }} \
            --description "Automated upstream sync analysis" \
            --color "0366d6" 2>/dev/null || true

          gh label create "automated" \
            --repo ${{ github.repository }} \
            --description "Automatically generated" \
            --color "6f42c1" 2>/dev/null || true

      - name: Add upstream remote and fetch
        if: steps.check.outputs.skip != 'true'
        env:
          RELEASE_TAG: ${{ steps.upstream.outputs.tag }}
        run: |
          echo "Adding upstream remote..."
          git remote add upstream https://github.com/alexta69/metube.git

          echo "Fetching upstream tags..."
          git fetch upstream --tags --force

          echo "Verifying tag $RELEASE_TAG exists..."
          git rev-parse "$RELEASE_TAG" || {
            echo "Error: Tag $RELEASE_TAG not found"
            exit 1
          }

      - name: Generate diff
        if: steps.check.outputs.skip != 'true'
        env:
          RELEASE_TAG: ${{ steps.upstream.outputs.tag }}
          LAST_SYNCED: ${{ steps.sync_state.outputs.last_synced }}
          HAS_SYNC_HISTORY: ${{ steps.sync_state.outputs.has_sync_history }}
        run: |
          echo "Generating diff statistics..."

          # Determine diff base: upstream-to-upstream if we have sync history, otherwise fork HEAD
          if [ "$HAS_SYNC_HISTORY" = "true" ] && [ -n "$LAST_SYNCED" ]; then
            DIFF_BASE="$LAST_SYNCED"
            echo "Using upstream-to-upstream diff: $LAST_SYNCED -> $RELEASE_TAG"
          else
            DIFF_BASE="HEAD"
            echo "First run, using fork HEAD as diff base"
          fi

          # Primary diff: upstream changes only (what's new since last sync)
          git diff ${DIFF_BASE}...${RELEASE_TAG} --stat > /tmp/diff_stat.txt

          # Get full diff (truncated to ~50KB for LLM context)
          git diff ${DIFF_BASE}...${RELEASE_TAG} | head -c 50000 > /tmp/diff_full.txt

          # Check if diff was truncated
          FULL_SIZE=$(git diff ${DIFF_BASE}...${RELEASE_TAG} | wc -c)
          if [ "$FULL_SIZE" -gt 50000 ]; then
            echo -e "\n\n... [DIFF TRUNCATED - original size: $FULL_SIZE bytes] ..." >> /tmp/diff_full.txt
          fi

          # Get list of changed files
          git diff ${DIFF_BASE}...${RELEASE_TAG} --name-only > /tmp/changed_files.txt

          # Secondary: fork gap context (for reference only)
          if [ "$HAS_SYNC_HISTORY" = "true" ]; then
            echo "" >> /tmp/diff_stat.txt
            echo "--- Fork Gap (HEAD vs latest upstream) ---" >> /tmp/diff_stat.txt
            git diff HEAD...${RELEASE_TAG} --stat >> /tmp/diff_stat.txt 2>/dev/null || true
          fi

          echo "Diff generated. Files changed in upstream:"
          cat /tmp/diff_stat.txt

      - name: Call LLM for analysis
        if: steps.check.outputs.skip != 'true'
        id: llm
        env:
          LLM_PROVIDER_API_KEY: ${{ secrets.LLM_PROVIDER_API_KEY }}
          LLM_PROVIDER_MODEL: ${{ secrets.LLM_PROVIDER_MODEL }}
          LLM_PROVIDER_URL: ${{ secrets.LLM_PROVIDER_URL }}
          RELEASE_TAG: ${{ steps.upstream.outputs.tag }}
          RELEASE_URL: ${{ steps.upstream.outputs.url }}
          RELEASE_PUBLISHED: ${{ steps.upstream.outputs.published }}
          LAST_SYNCED: ${{ steps.sync_state.outputs.last_synced }}
          HAS_SYNC_HISTORY: ${{ steps.sync_state.outputs.has_sync_history }}
          RELEASES_LIST: ${{ steps.releases.outputs.releases_list }}
          RELEASE_COUNT: ${{ steps.releases.outputs.release_count }}
        run: |
          # Read generated files
          RELEASE_NOTES=$(cat /tmp/release_notes.txt)
          DIFF_STAT=$(cat /tmp/diff_stat.txt)
          DIFF_FULL=$(cat /tmp/diff_full.txt)
          CHANGED_FILES=$(cat /tmp/changed_files.txt)
          TODAY=$(date +'%Y-%m-%d')

          # Build sync status context
          if [ "$HAS_SYNC_HISTORY" = "true" ]; then
            SYNC_CONTEXT="## Fork Sync Status
          - **Last synced upstream version**: $LAST_SYNCED
          - **Analyzing changes up to**: $RELEASE_TAG
          - **New releases in this analysis**: $RELEASES_LIST ($RELEASE_COUNT total)
          - **Fork has customizations**: Yes (POT plugin, error handling, UI changes)

          ## Analysis Scope
          The diff below shows ONLY what changed in upstream between $LAST_SYNCED and $RELEASE_TAG.
          Do NOT report changes from releases <= $LAST_SYNCED as those are already incorporated.
          "
          else
            SYNC_CONTEXT="## Fork Sync Status
          - **First analysis** - no previous sync history
          - **Analyzing release**: $RELEASE_TAG
          "
          fi

          # Construct the prompt
          PROMPT=$(cat <<'PROMPT_EOF'
          You are analyzing upstream changes to help a fork maintainer decide whether to merge.

          ## Context
          - **Upstream Repository**: alexta69/metube (YouTube downloader web app)
          - **Upstream Release**: RELEASE_TAG_PLACEHOLDER (published: RELEASE_PUBLISHED_PLACEHOLDER)
          - **Release URL**: RELEASE_URL_PLACEHOLDER

          SYNC_CONTEXT_PLACEHOLDER

          ## Important Instructions
          - Focus ONLY on what changed between the last synced version and the new release(s)
          - The diff provided shows upstream-to-upstream changes (not fork differences)
          - Do NOT report changes that were in previous releases already synced
          - Provide actionable insights for merging decisions

          ## Upstream Release Notes
          ```
          RELEASE_NOTES_PLACEHOLDER
          ```

          ## Changed Files
          ```
          CHANGED_FILES_PLACEHOLDER
          ```

          ## Diff Statistics
          ```
          DIFF_STAT_PLACEHOLDER
          ```

          ## Detailed Changes
          ```diff
          DIFF_FULL_PLACEHOLDER
          ```

          ---

          Please provide your analysis in the following markdown format:

          ## New Features
          List any new features added in this upstream release. If none, state "None identified."

          ## Breaking Changes
          Identify any breaking changes that could affect downstream forks. If none, state "None identified."

          ## Dependency Updates
          List any updated dependencies and their version changes. If none, state "None identified."

          ## Security Fixes
          Highlight any security-related changes or fixes. If none, state "None identified."

          ## Mergeability Score: X/10
          Rate from 1-10 where:
          - 1-3: Major changes, high risk of conflicts, careful review needed
          - 4-6: Moderate changes, some review required
          - 7-9: Minor changes, low risk
          - 10: Trivial or no changes

          Provide a brief justification for your score.

          ## Recommended Actions
          Provide 2-4 specific actionable steps for the fork maintainer.
          PROMPT_EOF
          )

          # Replace placeholders
          PROMPT="${PROMPT//RELEASE_TAG_PLACEHOLDER/$RELEASE_TAG}"
          PROMPT="${PROMPT//RELEASE_PUBLISHED_PLACEHOLDER/$RELEASE_PUBLISHED}"
          PROMPT="${PROMPT//RELEASE_URL_PLACEHOLDER/$RELEASE_URL}"
          PROMPT="${PROMPT//SYNC_CONTEXT_PLACEHOLDER/$SYNC_CONTEXT}"
          PROMPT="${PROMPT//RELEASE_NOTES_PLACEHOLDER/$RELEASE_NOTES}"
          PROMPT="${PROMPT//CHANGED_FILES_PLACEHOLDER/$CHANGED_FILES}"
          PROMPT="${PROMPT//DIFF_STAT_PLACEHOLDER/$DIFF_STAT}"
          PROMPT="${PROMPT//DIFF_FULL_PLACEHOLDER/$DIFF_FULL}"

          # Prepare JSON payload
          PAYLOAD=$(jq -n \
            --arg model "$LLM_PROVIDER_MODEL" \
            --arg prompt "$PROMPT" \
            '{
              model: $model,
              messages: [
                {
                  role: "user",
                  content: $prompt
                }
              ],
              max_tokens: 4000
            }')

          # Retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."

            HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" \
              -X POST "$LLM_PROVIDER_URL" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $LLM_PROVIDER_API_KEY" \
              -d "$PAYLOAD")

            HTTP_CODE=$(echo "$HTTP_RESPONSE" | tail -n1)
            RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')

            if [ "$HTTP_CODE" = "200" ]; then
              SUCCESS=true
              echo "API call successful!"

              # Extract the content from the response
              ANALYSIS=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // empty')

              if [ -z "$ANALYSIS" ]; then
                echo "Error: Empty response from API"
                SUCCESS=false
              else
                echo "$ANALYSIS" > /tmp/analysis.md
              fi
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "API call failed with status $HTTP_CODE"
              echo "Response: $RESPONSE_BODY"

              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                SLEEP_TIME=$((RETRY_COUNT * 5))
                echo "Retrying in $SLEEP_TIME seconds..."
                sleep $SLEEP_TIME
              fi
            fi
          done

          if [ "$SUCCESS" = "false" ]; then
            echo "All retry attempts failed. Creating error report."
            cat > /tmp/analysis.md <<EOF
          ## Analysis Failed

          The automated analysis could not be completed after $MAX_RETRIES attempts.

          **Error**: API returned status code $HTTP_CODE

          Please manually review the upstream release:
          - **Release**: $RELEASE_TAG
          - **URL**: $RELEASE_URL

          ### Changed Files
          \`\`\`
          $(cat /tmp/changed_files.txt)
          \`\`\`

          ### Diff Statistics
          \`\`\`
          $(cat /tmp/diff_stat.txt)
          \`\`\`
          EOF
            echo "error=true" >> $GITHUB_OUTPUT
          else
            echo "error=false" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Issue
        if: steps.check.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.TATOALO_REPO_PAT }}
          RELEASE_TAG: ${{ steps.upstream.outputs.tag }}
          RELEASE_URL: ${{ steps.upstream.outputs.url }}
          RELEASE_PUBLISHED: ${{ steps.upstream.outputs.published }}
          ANALYSIS_ERROR: ${{ steps.llm.outputs.error }}
          LAST_SYNCED: ${{ steps.sync_state.outputs.last_synced }}
          RELEASES_LIST: ${{ steps.releases.outputs.releases_list }}
          RELEASE_COUNT: ${{ steps.releases.outputs.release_count }}
        run: |
          TODAY=$(date +'%Y-%m-%d')
          ANALYSIS=$(cat /tmp/analysis.md)

          # Determine labels based on success/failure
          if [ "$ANALYSIS_ERROR" = "true" ]; then
            LABELS="upstream-sync,automated,needs-attention"
            # Create needs-attention label if it doesn't exist
            gh label create "needs-attention" \
              --repo ${{ github.repository }} \
              --description "Requires manual review" \
              --color "d93f0b" --force 2>&1 || true
          else
            LABELS="upstream-sync,automated"
          fi

          # Build sync status header
          if [ -n "$LAST_SYNCED" ]; then
            SYNC_HEADER="**Last synced**: $LAST_SYNCED | **New releases**: $RELEASES_LIST"
          else
            SYNC_HEADER="**First analysis** (no previous sync history)"
          fi

          # Create issue body
          cat > /tmp/issue_body.md <<EOF
          # Upstream Sync Analysis: $RELEASE_TAG

          **Analyzed**: $TODAY | **Released**: ${RELEASE_PUBLISHED:0:10}
          $SYNC_HEADER
          [View Release]($RELEASE_URL)

          ---

          $ANALYSIS

          ---

          *This analysis was automatically generated. Please review before taking action.*

          **After syncing**, simply close this issue - a \`synced:$RELEASE_TAG\` label will be applied automatically.
          EOF

          # Create the issue
          ISSUE_BODY=$(cat /tmp/issue_body.md)

          # Build labels array
          IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
          LABELS_JSON=$(printf '%s\n' "${LABEL_ARRAY[@]}" | jq -R . | jq -s .)

          ISSUE_RESPONSE=$(curl -s -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/issues" \
            -d "$(jq -n \
              --arg title "Upstream Sync Analysis: $RELEASE_TAG" \
              --arg body "$ISSUE_BODY" \
              --argjson labels "$LABELS_JSON" \
              '{title: $title, body: $body, labels: $labels}')")

          ISSUE_URL=$(echo "$ISSUE_RESPONSE" | jq -r '.html_url // empty')

          if [ -z "$ISSUE_URL" ]; then
            echo "Failed to create issue. Response:"
            echo "$ISSUE_RESPONSE" | jq .
            exit 1
          fi

          echo "Issue created: $ISSUE_URL"
          echo "issue_url=$ISSUE_URL" >> $GITHUB_OUTPUT

      - name: Summary
        if: always()
        env:
          SKIP: ${{ steps.check.outputs.skip }}
          SKIP_REASON: ${{ steps.check.outputs.skip_reason }}
          EXISTING_ISSUE: ${{ steps.check.outputs.existing_issue }}
          RELEASE_TAG: ${{ steps.upstream.outputs.tag }}
          LAST_SYNCED: ${{ steps.sync_state.outputs.last_synced }}
          RELEASE_COUNT: ${{ steps.releases.outputs.release_count }}
        run: |
          echo "## Upstream Sync Check Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Latest upstream release**: $RELEASE_TAG" >> $GITHUB_STEP_SUMMARY
          echo "**Last synced version**: ${LAST_SYNCED:-N/A (first run)}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$SKIP" = "true" ]; then
            if [ "$SKIP_REASON" = "already_synced" ]; then
              echo "**Status**: Skipped - already synced to $LAST_SYNCED (no new releases)" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Status**: Skipped - already analyzed in issue #$EXISTING_ISSUE" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "**Status**: Analysis completed for $RELEASE_COUNT new release(s)" >> $GITHUB_STEP_SUMMARY
          fi
